default: &base
  dispatchers:
    - polling_interval: 0.5
      batch_size: 100

  # Single worker for development — both region queues + everything else.
  workers:
    - queues:
        - character_sync_us
        - character_sync_eu
        - pvp_sync_2v2
        - pvp_sync_3v3
        - pvp_sync_rbg
        - pvp_sync_shuffle
        - pvp_processing
        - "*"
      threads: <%= ENV.fetch("SOLID_QUEUE_THREADS", 5) %>
      processes: 1
      polling_interval: 0.25

development:
  <<: *base

production: &production
  dispatchers:
    - polling_interval: 0.5
      batch_size: 100

  workers:
    # US characters — dedicated worker so a Blizzard US rate-limit never stalls EU.
    # Batch jobs handle internal concurrency with async fibers (PVP_SYNC_CONCURRENCY).
    - queues: [character_sync_us]
      threads: <%= ENV.fetch("PVP_SYNC_THREADS", 3) %>
      processes: 1
      polling_interval: 0.25

    # EU characters — independent from US, separate Blizzard rate-limit bucket.
    - queues: [character_sync_eu]
      threads: <%= ENV.fetch("PVP_SYNC_THREADS", 3) %>
      processes: 1
      polling_interval: 0.25

    # Leaderboard sync + bracket-specific queues
    - queues:
        - pvp_sync_2v2
        - pvp_sync_3v3
        - pvp_sync_rbg
        - pvp_sync_shuffle
      threads: <%= ENV.fetch("PVP_SYNC_THREADS", 3) %>
      processes: 1
      polling_interval: 0.25

    # CPU-bound: aggregations + default catch-all
    - queues: [pvp_processing, "*"]
      threads: <%= ENV.fetch("PVP_PROCESSING_THREADS", 3) %>
      processes: 1
      polling_interval: 0.25

# Low-resource profile for cheap cloud instances (2 vCPU, 2GB RAM)
# Use with: QUEUE_PROFILE=low_resource
low_resource:
  dispatchers:
    - polling_interval: 1.0
      batch_size: 50

  workers:
    - queues: "*"
      threads: 2
      processes: 1
      polling_interval: 1.0
